<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>3rd Space POS</title>
  <style>
    body { font-family: system-ui, -apple-system, sans-serif; margin:0; background:#f6f7f9;}
    header { position: sticky; top:0; background:#111827; color:white; padding:12px 14px; display:flex; gap:10px; align-items:center; z-index:10;}
    header .title { font-weight:700; }
    header .pill { padding:6px 10px; border-radius:999px; font-size:12px; background:#374151; }
    header .pill.ok { background:#065f46; }
    header .pill.bad { background:#7f1d1d; }
    header button { background:#2563eb; color:white; border:0; padding:10px 12px; border-radius:10px; font-weight:600; }
    header button#syncBtn { margin-left:0; } /* keep normal */
    header button#voidBtn { margin-left:auto; background:#111827; } /* push void button to the right (before Sync) */

    main {
  display: grid;
  grid-template-columns: minmax(0, 1fr) 360px;
  gap: 12px;
  padding: 12px;
}

    @media (max-width: 900px) { main { grid-template-columns: 1fr; } }

    .grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
  gap: 12px;
}


    .card { background:white; border-radius:14px; padding:8px; box-shadow:0 2px 10px rgba(0,0,0,.05); }
    .item { display:flex; flex-direction:column; gap:6px; }
    .photo { height:120px; border-radius:12px; background:linear-gradient(135deg,#e5e7eb,#f9fafb); display:flex; align-items:center; justify-content:center; color:#6b7280; font-size:12px; }
    .name { font-weight:700; font-size:14px; line-height:1.2; }
    .meta { display:flex; justify-content:space-between; color:#6b7280; font-size:12px; }
    .price { font-weight:800; color:#111827; }
    .remain { font-weight:700; }
    .btn { width:100%; padding:10px; border-radius:12px; border:0; font-weight:800; background:#111827; color:white; }
    .btn:disabled { background:#9ca3af; }
    .tabs { display:flex; gap:8px; margin-bottom:10px; }
    .tab { padding:8px 10px; border-radius:999px; background:#e5e7eb; font-weight:700; font-size:12px; cursor:pointer; user-select:none; }
    .tab.active { background:#111827; color:white; }

    .payRow { display:flex; gap:10px; margin-top:8px; }
    .payBtn {
      flex: 1;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid #e5e7eb;
      background: #f3f4f6;
      font-weight: 900;
      cursor: pointer;
    }
    .payBtn.active {
      background: #111827;
      color: white;
      border-color: #111827;
    }
    
    .cashBox { margin-top: 10px; display:none; }
    .cashQuick { display:grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap:10px; margin-top:8px; }
    .cashBtn {
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid #e5e7eb;
      background: #f3f4f6;
      font-weight: 900;
      cursor: pointer;
    }
    .cashBtn.active { background:#111827; color:#fff; border-color:#111827; }
    .cashManual { margin-top:10px; display:none; }
    .changeLine { margin-top:10px; font-weight:900; font-size:14px; }
    .changeLine .small { font-weight:700; }

    
    .cartRow { display:flex; justify-content:space-between; gap:10px; padding:8px 0; border-bottom:1px solid #eef2f7;}
    .cartRow .left { min-width:0; }
    .cartRow .sku { font-size:11px; color:#6b7280; }
    .cartRow .qty { display:flex; gap:6px; align-items:center; }
    .cartRow button { width:34px; height:34px; border-radius:10px; border:0; background:#e5e7eb; font-weight:900; }
    .totals { display:flex; justify-content:space-between; font-weight:900; font-size:18px; padding-top:10px; }
    .small { font-size:12px; color:#6b7280; }
    input, select { width:100%; padding:10px; border-radius:12px; border:1px solid #e5e7eb; font-size:14px; }
    .actions { display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-top:10px; }
    .primary { background:#16a34a; }
    .danger { background:#dc2626; }
    .receipt { white-space:pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; background:#0b1220; color:#e5e7eb; padding:12px; border-radius:12px; font-size:12px; }
    /* Category section wrapper (used in "All" view) */
.catSection {
  margin-bottom: 16px;
}

/* Category header styling */
.catHeader {
  font-weight: 900;
  font-size: 14px;
  margin: 12px 2px 8px;
  color: #111827;
  text-transform: uppercase;
  letter-spacing: 0.04em;
}
  /* All-view: stack category sections vertically for faster scanning */
.allSections {
  display: flex;
  flex-direction: column;
  gap: 16px;
}
    
.keypad {
  margin-top: 10px;
  padding: 10px;
  border-radius: 12px;
  border: 1px solid #e5e7eb;
  background: #fff;
}

.keypadGrid {
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 10px;
}

.keypadActions {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
  margin-top: 10px;
}

.key {
  padding: 14px 12px;
  border-radius: 12px;
  border: 1px solid #e5e7eb;
  background: #f3f4f6;
  font-weight: 900;
  font-size: 18px;
  cursor: pointer;
}

.key.secondary {
  background: #e5e7eb;
}

.key.done {
  background: #111827;
  color: #fff;
  border-color: #111827;
}
    
/* Void modal list rows clickable */
#voidSalesList .cartRow:hover { background:#f3f4f6; border-radius:10px; }
/* Highlight items that are being refunded (qty > 0) */
.voidingRow { background:#fef3c7; border-radius:10px; padding-left:8px; padding-right:8px; }


  </style>
</head>
<body>
<header>
  <div class="title">3rd Space POS</div>
  <div id="netPill" class="pill bad">Offline</div>
  <div id="syncPill" class="pill">Queue: 0</div>
  <button id="voidBtn" type="button">Void / Refund</button>
  <button id="syncBtn" type="button">Sync</button>

</header>

<main>
  <section>
    <div class="card">
      <div class="tabs" id="catTabs"></div>
      <div class="grid" id="itemsGrid"></div>
      <div class="small" style="margin-top:8px;">
        Tip: Add to Home Screen for full-screen app. Inventory disables items at 0 remaining.
      </div>
    </div>
  </section>

  <aside class="card">
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <div style="font-weight:900; font-size:18px;">Cart</div>
      <button class="btn danger" id="clearBtn" type="button" style="width:auto; padding:10px 12px;">Clear</button>
    </div>

    <div id="cart"></div>

<div class="totals">
  <div>Total</div>
  <div id="total">$0.00</div>
</div>


    <div style="margin-top:12px;">
<label class="small">Payment Type</label>
<div class="payRow">
  <button id="payCash" type="button" class="payBtn active">Cash</button>
  <button id="payVenmo" type="button" class="payBtn">Venmo</button>
  <button id="payComp" type="button" class="payBtn">Comp</button>
</div>

<!-- Cash tender UI -->
<div id="cashBox" class="cashBox">
  <label class="small" style="display:block; margin-top:10px;">Cash Received</label>

  <div class="cashQuick">
    <button type="button" class="cashBtn" data-amt="5">$5</button>
    <button type="button" class="cashBtn" data-amt="10">$10</button>
    <button type="button" class="cashBtn" data-amt="15">$15</button>
    <button type="button" class="cashBtn" data-amt="20">$20</button>
    <button type="button" class="cashBtn" data-amt="50">$50</button>
    <button type="button" class="cashBtn" data-amt="other">Other</button>
  </div>

<div id="cashManual" class="cashManual">
  <label class="small" style="display:block;">Enter amount</label>
  <input
    id="cashOther"
    type="text"
    inputmode="none"
    readonly
    placeholder="Tap to enter amount"
  />
</div>

<!-- Custom keypad (no OS keyboard) -->
<div id="keypad" class="keypad" style="display:none;">
  <div class="keypadGrid">
    <button type="button" class="key" data-k="1">1</button>
    <button type="button" class="key" data-k="2">2</button>
    <button type="button" class="key" data-k="3">3</button>

    <button type="button" class="key" data-k="4">4</button>
    <button type="button" class="key" data-k="5">5</button>
    <button type="button" class="key" data-k="6">6</button>

    <button type="button" class="key" data-k="7">7</button>
    <button type="button" class="key" data-k="8">8</button>
    <button type="button" class="key" data-k="9">9</button>

    <button type="button" class="key secondary" data-k=".">.</button>
    <button type="button" class="key" data-k="0">0</button>
    <button type="button" class="key secondary" data-k="back">⌫</button>
  </div>

  <div class="keypadActions">
    <button type="button" class="key secondary" id="keyClear">Clear</button>
    <button type="button" class="key done" id="keyDone">Done</button>
  </div>
</div>


  <div class="changeLine">
    <span class="small">Change Due:</span>
    <span id="changeDue">$0.00</span>
  </div>
</div>

    </div>

    <div style="margin-top:10px;">
      <label class="small">Customer Email (optional)</label>
      <input id="email" type="email" placeholder="name@email.com" autocomplete="email" />
      <div class="small">If offline, receipt will send later when synced.</div>
    </div>

    <div class="actions">
      <button class="btn primary" id="checkoutBtn" type="button">Complete Sale</button>
      <button class="btn" id="printBtn" type="button">Show Receipt</button>
    </div>

    <div id="receiptBox" style="margin-top:12px; display:none;">
      <div style="font-weight:900; margin-bottom:6px;">Receipt</div>
      <div class="receipt" id="receipt"></div>
    </div>
  </aside>
 </main>
<!-- VOID / REFUND MODAL GOOD ONE!!!-->
<div id="voidModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.55); z-index:9999; padding:12px;">
  <div class="card" style="max-width:980px; margin:0 auto; padding:12px; height:calc(100vh - 24px); display:flex; flex-direction:column;">
    <div style="display:flex; justify-content:space-between; align-items:center; gap:10px;">
      <div style="font-weight:900; font-size:18px;">Void / Refund (After-Sale)</div>
      <button id="voidCloseBtn" type="button" class="btn danger" style="width:auto; padding:10px 12px;">Close</button>
    </div>

    <div class="small" style="margin-top:6px;">
      This creates a negative money correction and does <b>NOT</b> restore inventory (comp/spoil policy).
    </div>

    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:12px; margin-top:12px; min-height:0; flex:1;">
      <!-- LEFT: sales list -->
      <div class="card" style="padding:10px; overflow:auto;">
        <div style="font-weight:900; margin-bottom:8px;">Select a Sale</div>
        <div id="voidSalesList"></div>
      </div>

      <!-- RIGHT: items + reason + refund method -->
      <div class="card" style="padding:10px; overflow:auto;">
        <div style="font-weight:900; margin-bottom:8px;">Select Items to Refund</div>
        <div id="voidItemsList">
          <div class="small">Select a sale on the left.</div>
        </div>

        <div style="margin-top:12px;">
          <label class="small">Refund Method</label>
          <div class="payRow">
            <button id="refundCash" type="button" class="payBtn active">Cash</button>
            <button id="refundVenmo" type="button" class="payBtn">Venmo</button>
          </div>
        </div>

        <div style="margin-top:12px;">
          <label class="small">Reason (required)</label>
          <input id="voidReason" type="text" placeholder="e.g. Spoiled / Wrong item / Customer issue" />
        </div>

        <div class="totals" style="margin-top:12px;">
          <div>Refund Total</div>
          <div id="voidTotal">$0.00</div>
        </div>

        <div style="margin-top:12px;">
          <button id="voidConfirmBtn" type="button" class="btn danger">Confirm Void / Refund</button>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/** ====== CONFIG: set these ====== **/
const API_URL = "https://script.google.com/macros/s/AKfycby54tn2RVqEqH_E8YSwCvcigQCI8_vMlEYK9zIu_QuU5KUS7C84X1193eXl4zGvHMdV/exec";
// const API_URL = "https://script.google.com/macros/s/AKfycbw3L7d58jMTxfNiirhzxrob3tZCsyx8p5S0zmJjsHLQa25lRDdlXcPaSasYS5Vc6mQQhg/exec"; //UAT
  
const TOKEN   = "pos_3rdspace_7F2qM9xR4WkB8DLaYp6N3EJHcT5V";
const DONATION_PER_ALC = 5;

function isAlcoholSku_(sku) {
  return String(sku || "").trim().startsWith("ALC-");
}

function unitPriceForSku_(sku, basePrice) {
  return isAlcoholSku_(sku) ? DONATION_PER_ALC : (Number(basePrice) || 0);
}

/** ====== STORAGE KEYS ====== **/
const K_ITEMS = "pos_items_cache_v1";
const K_QUEUE = "pos_sales_queue_v1";
const K_INV   = "pos_inv_local_v1"; // local remaining by sku
const K_SALES = "pos_sales_history_v1"; // local log of completed sales (for void/refund UI)

function getSalesHistory() {
  return loadJSON(K_SALES, []);
}

function addSaleToHistory(sale) {
  const history = getSalesHistory();
  history.unshift(sale);                 // newest first
  history.splice(200);                   // keep last 200
  saveJSON(K_SALES, history);
}

/** ====== STATE ====== **/
let items = [];
let categories = [];
let activeCategory = "All";
let cart = {}; // sku -> qty

let paymentType = "Cash";       // "Cash" or "Venmo"
let cashTendered = null;        // number or null
let cashMode = null;            // 5/10/15/20/50/"other"/null
let selectedSaleForVoid = null;     // the original sale object
let voidCart = {};                  // sku -> qty to void
let refundMethod = "Cash";          // "Cash" or "Venmo"
let isCheckingOut = false;          // prevents double-submit on Complete Sale



/** ====== UTILS ====== **/
const $ = (id) => document.getElementById(id);
const money = (n) => `$${(Number(n)||0).toFixed(2)}`;
const nowIso = () => new Date().toISOString();

  function clearCustomerEmail() {
  const el = $("email");
  if (el) el.value = "";
}

/*** ====== VOID HELPERS (Step 7.3) ====== ***/
function getVoidRefundTotal() {
  if (!selectedSaleForVoid) return 0;

  let refund = 0;
  selectedSaleForVoid.items.forEach(it => {
    const q = Number(voidCart[it.sku] || 0);
    refund += q * Number(it.unitPrice);
  });

  return refund;
}

function updateVoidConfirmEnabled() {
  const refund = getVoidRefundTotal();
  const ok = !!selectedSaleForVoid && refund > 0;
  $("voidConfirmBtn").disabled = !ok;
}

function getRefundedQtyMapForSale(originalSaleId) {
  const history = getSalesHistory();
  const refunded = {}; // sku -> qty already refunded

  history
    .filter(x => x.type === "void" && x.originalSaleId === originalSaleId)
    .forEach(v => {
      (v.items || []).forEach(it => {
        const sku = it.sku;
        refunded[sku] = (refunded[sku] || 0) + Number(it.qty || 0);
      });
    });

  return refunded;
}

  
/** ====== KEYPAD (Custom Cash Entry) ====== **/
function showKeypad(show) {
  $("keypad").style.display = show ? "block" : "none";
}

function setCashOtherValue(next) {
  $("cashOther").value = next;
  updateChangeDue();
  updateCheckoutEnabled();
}

function keypadAppend(ch) {
  let v = $("cashOther").value || "";

  // allow only one decimal
  if (ch === "." && v.includes(".")) return;

  // prevent leading zeros like "00" (but allow "0." etc.)
  if (v === "0" && ch !== ".") v = "";

  // max 2 decimals
  if (v.includes(".")) {
    const parts = v.split(".");
    const decimals = parts[1] || "";
    if (decimals.length >= 2) return;
  }

  setCashOtherValue(v + ch);
}


function keypadBackspace() {
  const v = $("cashOther").value || "";
  setCashOtherValue(v.slice(0, -1));
}

function uuidv4() {
  // good enough for this use-case
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, c => {
    const r = Math.random()*16|0, v = c === "x" ? r : (r&0x3|0x8);
    return v.toString(16);
  });
}

function loadJSON(key, fallback) {
  try { return JSON.parse(localStorage.getItem(key)) ?? fallback; }
  catch { return fallback; }
}
function saveJSON(key, val) { localStorage.setItem(key, JSON.stringify(val)); }

function setOnlineUI(isOnline) {
  $("netPill").textContent = isOnline ? "Online" : "Offline";
  $("netPill").className = "pill " + (isOnline ? "ok" : "bad");
}

async function refreshOnlineStatus() {
  try {
    const url = `${API_URL}?route=items&token=${encodeURIComponent(TOKEN)}`;
    const res = await fetch(url, { method: "GET", cache: "no-store" });

    // ✅ If we got ANY HTTP response, we're online
    setOnlineUI(true);

  } catch (e) {
    // ❌ If fetch throws, we’re actually offline (or blocked)
    setOnlineUI(false);
  }
}


/** ====== API ====== **/
async function apiGetItems() {
  const url = `${API_URL}?route=items&token=${encodeURIComponent(TOKEN)}`;
  const res = await fetch(url, { method:"GET" });
  const json = await res.json();
  if (!json.ok) throw new Error(json.error || "Failed to load items");

  // ✅ If we successfully got JSON, we're online
  setOnlineUI(true);

  return json.items;
}


async function apiPostBatch(sales) {
  const url = `${API_URL}?route=batch&token=${encodeURIComponent(TOKEN)}`;
  const res = await fetch(url, {
    method: "POST",
    body: JSON.stringify({ sales }) // default becomes text/plain; charset=UTF-8 (simple request)
  });
  const json = await res.json();
  if (!json.ok) throw new Error(json.error || "Batch sync failed");
  return json.results || [];
}

/** ====== INVENTORY ====== **/
function getLocalInv() {
  return loadJSON(K_INV, {});
}
function setLocalInv(inv) {
  saveJSON(K_INV, inv);
}
function ensureLocalInvInitialized(fromItems) {
  const inv = getLocalInv();
  let changed = false;
  for (const it of fromItems) {
    if (inv[it.sku] === undefined) { inv[it.sku] = Number(it.remaining)||0; changed = true; }
  }
  if (changed) setLocalInv(inv);
  return inv;
}

  // Rebuild local inventory from server remaining, then apply any unsynced queued sales.
// NOTE: voids/refunds do NOT restore inventory by design.
function rebuildLocalInvFromServerAndQueue(freshItems) {
  const inv = Object.fromEntries(
    freshItems.map(i => [i.sku, Number(i.remaining) || 0])
  );

  const q = loadJSON(K_QUEUE, []);
  q.forEach(txn => {
    if (txn.type === "sale") {
      txn.items.forEach(it => {
        inv[it.sku] = Math.max(0, (inv[it.sku] ?? 0) - Number(it.qty));
      });
    }
    // txn.type === "void" intentionally does nothing to inventory
  });

  setLocalInv(inv);
  return inv;
}


/** ====== RENDER ====== **/
function computeCategories() {
  const set = new Set(items.map(i => i.category));
  categories = ["All", ...Array.from(set).sort()];
  if (!categories.includes(activeCategory)) activeCategory = "All";
}

function renderTabs() {
  const wrap = $("catTabs");
  wrap.innerHTML = "";
  categories.forEach(cat => {
    const el = document.createElement("div");
    el.className = "tab" + (cat === activeCategory ? " active" : "");
    el.textContent = cat;
    el.onclick = () => { activeCategory = cat; render(); };
    wrap.appendChild(el);
  });
}

function renderItems() {
  const grid = $("itemsGrid");
  grid.innerHTML = "";

  const inv = getLocalInv();

  // Helper: build an item card
  function makeItemCard(it) {
    const baseRemaining = (inv[it.sku] !== undefined) ? inv[it.sku] : (Number(it.remaining) || 0);
    const inCart = cart[it.sku] ?? 0;
    const remaining = Math.max(0, baseRemaining - inCart);


    const card = document.createElement("div");
    card.className = "card item";

    const photo = document.createElement("div");
    photo.className = "photo";

    if (it.photoUrl) {
      const img = document.createElement("img");
      img.src = it.photoUrl;
      img.alt = it.name;
      img.loading = "lazy";
      img.style.width = "100%";
      img.style.height = "100%";
      img.style.objectFit = "contain";
      img.style.borderRadius = "12px";
      photo.appendChild(img);
    } else {
      photo.textContent = "Photo";
    }

card.appendChild(photo);

    const name = document.createElement("div");
    name.className = "name";
    name.textContent = it.name;
    card.appendChild(name);

    const meta = document.createElement("div");
    meta.className = "meta";
    meta.innerHTML = `<span class="price">${money(it.price)}</span><span class="remain">${remaining} left</span>`;
    card.appendChild(meta);

    const btn = document.createElement("button");
    btn.className = "btn";
    btn.textContent = "Add";
    btn.disabled = remaining <= 0;
    btn.onclick = () => addToCart(it.sku);
    card.appendChild(btn);

    return card;
  }

  // If a specific category is selected, keep the simple grid
  if (activeCategory !== "All") {
    const filtered = items.filter(i => i.category === activeCategory);
    filtered.forEach(it => grid.appendChild(makeItemCard(it)));
    return;
  }

// "All" view: group by category with headers + separate grids
cconst preferredOrder = ["Beverage (NA)", "Food"];

const cats = Array.from(new Set(items.map(i => i.category)))
  .sort((a, b) => {
    const ai = preferredOrder.indexOf(a);
    const bi = preferredOrder.indexOf(b);
    const aRank = (ai === -1) ? 999 : ai;
    const bRank = (bi === -1) ? 999 : bi;
    if (aRank !== bRank) return aRank - bRank;
    return String(a).localeCompare(String(b));
  });

// Wrapper to stack sections vertically
const wrapper = document.createElement("div");
wrapper.className = "allSections";

cats.forEach(cat => {
  const section = document.createElement("div");
  section.className = "catSection";

  const header = document.createElement("div");
  header.className = "catHeader";
  header.textContent = cat;

  const subgrid = document.createElement("div");
  subgrid.className = "grid";

  items
    .filter(i => i.category === cat)
    .forEach(it => subgrid.appendChild(makeItemCard(it)));

  section.appendChild(header);
  section.appendChild(subgrid);
  wrapper.appendChild(section);
});

grid.appendChild(wrapper);
}

function renderCart() {
  const wrap = $("cart");
  wrap.innerHTML = "";

  const inv = getLocalInv();
  const entries = Object.entries(cart);
  if (entries.length === 0) {
    wrap.innerHTML = `<div class="small" style="padding:12px 0;">Cart is empty.</div>`;
    $("total").textContent = money(0);
    updateChangeDue();
updateCheckoutEnabled();
    return;
  }

  let total = cartTotal();
  entries.forEach(([sku, qty]) => {
    const it = items.find(x => x.sku === sku);
    if (!it) return;

    const row = document.createElement("div");
    row.className = "cartRow";

    const left = document.createElement("div");
    left.className = "left";
    left.innerHTML = `<div style="font-weight:800; font-size:13px;">${it.name}</div><div class="sku">${sku}</div>`;
    row.appendChild(left);

    const right = document.createElement("div");
    right.className = "qty";

    const minus = document.createElement("button");
    minus.textContent = "−";
    minus.onclick = () => changeQty(sku, -1);

    const count = document.createElement("div");
    count.style.fontWeight = "900";
    count.textContent = qty;

    const plus = document.createElement("button");
    plus.textContent = "+";
    plus.onclick = () => {
      // enforce local hard inventory
      const remaining = inv[sku] ?? 0;
      const already = cart[sku] ?? 0;
      if (already >= remaining) return alert("Not enough inventory remaining.");
      changeQty(sku, +1);
    };

    right.appendChild(minus);
    right.appendChild(count);
    right.appendChild(plus);

    row.appendChild(right);
    wrap.appendChild(row);
  });

  $("total").textContent = money(total);
  updateChangeDue();
updateCheckoutEnabled();

}

function renderSyncPill() {
  const q = loadJSON(K_QUEUE, []);
  $("syncPill").textContent = `Queue: ${q.length}`;
}

function cartTotal() {
  return Object.entries(cart).reduce((sum, [sku, qty]) => {
    const it = items.find(x => x.sku === sku);
    if (!it) return sum;
    const unit = unitPriceForSku_(sku, it.price);
    return sum + (Number(qty) * unit);
  }, 0);
}


  
function setPayment(type) {
  const prev = paymentType;
  paymentType = type;

  // toggle button UI
  $("payCash").classList.toggle("active", type === "Cash");
  $("payVenmo").classList.toggle("active", type === "Venmo");
  $("payComp").classList.toggle("active", type === "Comp");

  // show/hide cash tender section
  $("cashBox").style.display = (type === "Cash") ? "block" : "none";

  // If switching away from Cash, always hide keypad
  if (type !== "Cash") showKeypad(false);

  // Only reset tender state when the payment type CHANGES
  if (prev !== type) {
    cashTendered = null;
    cashMode = null;
    setCashButtonsActive(null);
    $("cashManual").style.display = "none";
    if ($("cashOther")) $("cashOther").value = "";
  }

  updateChangeDue();
  updateCheckoutEnabled();
}





function setCashButtonsActive(mode) {
  document.querySelectorAll(".cashBtn").forEach(b => {
    b.classList.toggle("active", b.dataset.amt === String(mode));
  });
}

function parseCashOther() {
  const raw = ($("cashOther")?.value || "").trim();
  const val = parseFloat(raw);
  return isFinite(val) ? val : null;
}

function updateChangeDue() {
  const total = cartTotal();
  const tendered = (paymentType === "Cash") ? (cashTendered ?? (cashMode === "other" ? parseCashOther() : null)) : null;

  let change = 0;
  if (paymentType === "Cash" && tendered != null) change = tendered - total;
  $("changeDue").textContent = money(Math.max(0, change));
}

function updateCheckoutEnabled() {
  const total = cartTotal();

  // If cart empty, always block
  if (total <= 0) {
    $("checkoutBtn").disabled = true;
    return;
  }

  // Venmo or Comp: allowed as long as cart has items
  if (paymentType === "Venmo" || paymentType === "Comp") {
    $("checkoutBtn").disabled = false;
    return;
  }

  // Cash: require tendered >= total
  const tendered = (cashMode === "other") ? parseCashOther() : cashTendered;
  const ok = (tendered != null) && (tendered >= total);
  $("checkoutBtn").disabled = !ok;
}


function render() {
  computeCategories();
  renderTabs();
  renderItems();
  renderCart();
  renderSyncPill();
}



/** ====== CART ACTIONS ====== **/
function addToCart(sku) {
  const inv = getLocalInv();
  const remainingBase = inv[sku] ?? 0;
  const already = cart[sku] ?? 0;

  if (already >= remainingBase) return alert("Not enough inventory remaining.");

  cart[sku] = already + 1;

  renderItems();   // <-- REQUIRED so "left" updates immediately
  renderCart();
}


function changeQty(sku, delta) {
  const q = (cart[sku] ?? 0) + delta;

  if (q <= 0) delete cart[sku];
  else cart[sku] = q;

  renderItems();   // <-- REQUIRED so "left" increases back when removed
  renderCart();
}


function clearCart() {
  cart = {};
  $("receiptBox").style.display = "none";

  clearCustomerEmail();

  renderItems();
  renderCart();
}



/** ====== RECEIPT ====== **/
function formatDateMMDDYYYY(d) {
  const mm = String(d.getMonth() + 1).padStart(2, "0");
  const dd = String(d.getDate()).padStart(2, "0");
  const yyyy = d.getFullYear();
  return `${mm}/${dd}/${yyyy}`;
}

function formatTime12h(d) {
  let h = d.getHours();
  const m = String(d.getMinutes()).padStart(2, "0");
  const ampm = h >= 12 ? "pm" : "am";
  h = h % 12;
  if (h === 0) h = 12;
  return `${h}:${m}${ampm}`;
}

function buildReceiptText(sale) {
  const dt = new Date(sale.timestamp);
  const lines = [];

  lines.push("Thanks for supporting us!");
  lines.push("");
  
  if (sale.type === "void") {
    lines.push("Refund Receipt:");
  } else {
    lines.push("Receipt:");
  }
  lines.push("");


  // Line items
  sale.items.forEach(it => {
    const item = items.find(x => x.sku === it.sku);
    const name = item ? item.name : it.sku;
    lines.push(`${it.qty}x ${name} @ ${money(it.unitPrice)}`);
  });

  lines.push("");
  if (sale.type === "void") {
  lines.push(`Refund Method: ${sale.paymentType}`);
  if (sale.originalSaleId) lines.push(`Original Sale ID: ${sale.originalSaleId}`);
} else {
  lines.push(`Payment: ${sale.paymentType}`);
}


  // ---- Totals logic (IMPORTANT PART) ----
  const subtotal = (sale.subtotal != null)
    ? Number(sale.subtotal)
    : sale.items.reduce((s,it)=>s + it.qty * it.unitPrice, 0);

  const total = (sale.total != null)
    ? Number(sale.total)
    : subtotal;

if (sale.type === "void") {
  lines.push(`Refund Total: ${money(subtotal)}`);
} else {
  lines.push(`Subtotal: ${money(subtotal)}`);

  if (sale.paymentType === "Comp") {
    lines.push(`Total: ${money(0)}`);
    lines.push(`Comped: ${money(subtotal)}`);
  } else {
    lines.push(`Total: ${money(total)}`);
  }
}

  if (sale.paymentType === "Cash") {
    if (sale.cashGiven != null) {
      lines.push(`Cash given: ${money(sale.cashGiven)}`);
    }
    if (sale.changeProvided != null) {
      lines.push(`Change provided: ${money(sale.changeProvided)}`);
    }
  }

  lines.push("");
  lines.push(`Date: ${formatDateMMDDYYYY(dt)}`);
  lines.push(`Time: ${formatTime12h(dt)}`);
  if (sale.type === "void") {
  lines.push(`Void ID: ${sale.voidId}`);
} else {
  lines.push(`Sale ID: ${sale.saleId}`);
}


  return lines.join("\n");
}



function showReceipt(sale) {
  $("receipt").textContent = buildReceiptText(sale);
  $("receiptBox").style.display = "block";
}

/** ====== VOID / REFUND ====== **/
function openVoidModal() {
  $("voidModal").style.display = "block";
  selectedSaleForVoid = null;
  voidCart = {};
  refundMethod = "Cash";

  $("refundCash").classList.add("active");
  $("refundVenmo").classList.remove("active");
  $("voidReason").value = "";
  $("voidItemsList").innerHTML = `<div class="small">Select a sale on the left.</div>`;
  $("voidTotal").textContent = money(0);

  renderVoidSalesList();
  updateVoidConfirmEnabled();

}

function closeVoidModal() {
  $("voidModal").style.display = "none";
}

function renderVoidSalesList() {
  const history = getSalesHistory();
  const wrap = $("voidSalesList");
  wrap.innerHTML = "";

  const salesOnly = history.filter(s => s.type === "sale");

  if (!salesOnly.length) {
    wrap.innerHTML = `<div class="small">No sales found yet.</div>`;
    return;
  }

  salesOnly.forEach(sale => {
    const dt = new Date(sale.timestamp);

    const row = document.createElement("div");
    row.className = "cartRow";
    row.style.cursor = "pointer";
    row.innerHTML = `
      <div class="left">
        <div style="font-weight:900; font-size:13px;">${formatDateMMDDYYYY(dt)} ${formatTime12h(dt)}</div>
        <div class="small">Sale ID: ${sale.saleId}</div>
        <div class="small">Payment: ${sale.paymentType} • Collected: ${money(sale.total ?? 0)}</div>
      </div>
      <div style="font-weight:900;">Select</div>
    `;
    row.onclick = () => selectSaleForVoid(sale.saleId);
    wrap.appendChild(row);
  });
}

function selectSaleForVoid(saleId) {
  const sale = getSalesHistory().find(s => s.type === "sale" && s.saleId === saleId);
  if (!sale) return;

  selectedSaleForVoid = sale;

  voidCart = {};
  sale.items.forEach(it => { voidCart[it.sku] = 0; });

  renderVoidItemsList();
  updateVoidTotal();
}

function renderVoidItemsList() {
  const wrap = $("voidItemsList");
  wrap.innerHTML = "";

  if (!selectedSaleForVoid) {
    wrap.innerHTML = `<div class="small">Select a sale on the left.</div>`;
    return;
  }

  const refundedMap = getRefundedQtyMapForSale(selectedSaleForVoid.saleId);


  selectedSaleForVoid.items.forEach(it => {
    const item = items.find(x => x.sku === it.sku);
    const name = item ? item.name : it.sku;

    const row = document.createElement("div");
    row.className = "cartRow" + ((voidCart[it.sku] ?? 0) > 0 ? " voidingRow" : "");


    const left = document.createElement("div");
    left.className = "left";
    left.innerHTML = `
      <div style="font-weight:800; font-size:13px;">${name}</div>
      <div class="small">
  Sold: ${it.qty} @ ${money(it.unitPrice)} • Refunded: ${Number(refundedMap[it.sku] || 0)}
</div>
    `;

    const right = document.createElement("div");
    right.className = "qty";

    const minus = document.createElement("button");
    minus.textContent = "−";
    minus.onclick = () => {
      const cur = voidCart[it.sku] ?? 0;
      voidCart[it.sku] = Math.max(0, cur - 1);
      renderVoidItemsList();
      updateVoidTotal();
    };

    const count = document.createElement("div");
    count.style.fontWeight = "900";
    count.textContent = String(voidCart[it.sku] ?? 0);

    const plus = document.createElement("button");
    plus.textContent = "+";
    plus.onclick = () => {
  const alreadyRefunded = Number(refundedMap[it.sku] || 0);
  const maxRefundable = Math.max(0, Number(it.qty) - alreadyRefunded);

  const cur = voidCart[it.sku] ?? 0;
  if (cur >= maxRefundable) return;

  voidCart[it.sku] = cur + 1;
  renderVoidItemsList();
  updateVoidTotal();
};


    right.appendChild(minus);
    right.appendChild(count);
    right.appendChild(plus);

    row.appendChild(left);
    row.appendChild(right);
    wrap.appendChild(row);
  });
}

function updateVoidTotal() {
  const refund = getVoidRefundTotal();
  $("voidTotal").textContent = money(refund);
  updateVoidConfirmEnabled();
}

function buildVoidTransaction() {
  if (!selectedSaleForVoid) return null;

  const voidItems = selectedSaleForVoid.items
    .map(it => ({ sku: it.sku, qty: Number(voidCart[it.sku] || 0), unitPrice: Number(it.unitPrice) }))
    .filter(x => x.qty > 0);

  if (!voidItems.length) return null;

  const refundSubtotal = voidItems.reduce((s, it) => s + it.qty * it.unitPrice, 0);

  return {
  type: "void",
  voidId: uuidv4(),
  timestamp: nowIso(),

  originalSaleId: selectedSaleForVoid.saleId,
  paymentType: refundMethod,   // <-- IMPORTANT
  reason: ($("voidReason").value || "").trim(),

  items: voidItems,
  subtotal: refundSubtotal,
  total: -refundSubtotal
};
}

function confirmVoid() {
  const txn = buildVoidTransaction();
  if (!txn) return alert("Select at least 1 item to void/refund.");

  if (!txn.reason) return alert("Reason is required to process a void/refund.");
  
  if (!confirm(`Confirm refund for ${money(txn.subtotal)}? (Inventory will NOT be restored.)`)) return;

  enqueueSale(txn);
  addSaleToHistory(txn);
  showReceipt(txn);

  closeVoidModal();
  renderSyncPill();
}

  
/** ====== SALES: QUEUE + SYNC ====== **/
function enqueueSale(sale) {
  const q = loadJSON(K_QUEUE, []);
  q.push(sale);
  saveJSON(K_QUEUE, q);
  renderSyncPill();
}

function decrementLocalInventoryForSale(sale) {
  const inv = getLocalInv();
  sale.items.forEach(it => {
    inv[it.sku] = (inv[it.sku] ?? 0) - Number(it.qty);
    if (inv[it.sku] < 0) inv[it.sku] = 0;
  });
  setLocalInv(inv);
}

// ✅ syncQueue is NEXT (or very close below)
async function syncQueue() {
  const q = loadJSON(K_QUEUE, []);

  // Fix #2 goes HERE
if (q.length === 0) {
  if (navigator.onLine) {
    try {
      const fresh = await apiGetItems();
      items = fresh.filter(i => String(i.category || "").trim().toLowerCase() !== "alcohol");
      saveJSON(K_ITEMS, items);
      rebuildLocalInvFromServerAndQueue(items);
      render();
    } catch (e) {
      console.log(e);
    }
  }
  return;
}



  if (!navigator.onLine) {
    alert("Still offline. Sales are safely queued.");
    return;
  }

  // Send in one batch; server dedup + inventory enforcement
  const results = await apiPostBatch(q);

  // Remove only failures from queue
  const remaining = [];
  const failed = [];

  results.forEach((r, idx) => {
    if (r.ok) {
      // synced
    } else {
      failed.push(r);
      remaining.push(q[idx]);
    }
  });

  saveJSON(K_QUEUE, remaining);
  renderSyncPill();

  // Fix 2: ALWAYS refresh from server after sync attempt
  if (navigator.onLine) {
    try {
      const fresh = await apiGetItems();

// HARD BLOCK: remove Alcohol items entirely
items = fresh.filter(i => String(i.category || "").trim().toLowerCase() !== "alcohol");

saveJSON(K_ITEMS, items);
rebuildLocalInvFromServerAndQueue(items);
render();

    } catch (e) {
      console.log(e);
    }
  }

  if (failed.length) {
    alert(`Synced with ${failed.length} errors. First error: ${failed[0].error}`);
  }
}


/** ====== CHECKOUT ====== **/
async function completeSale() {
  // --- lock to prevent double charge / double submit ---
  if (isCheckingOut) return;
  isCheckingOut = true;
  $("checkoutBtn").disabled = true;

  try {
    const entries = Object.entries(cart);
    if (entries.length === 0) return alert("Cart is empty.");

    const inv = getLocalInv();
const saleItems = entries.map(([sku, qty]) => {
  const it = items.find(x => x.sku === sku);
  const unit = unitPriceForSku_(sku, it.price);
  return { sku, qty: Number(qty), unitPrice: unit };
});


    // local hard-inventory check
    for (const it of saleItems) {
      const remaining = inv[it.sku] ?? 0;
      if (it.qty > remaining) return alert(`Not enough inventory for ${it.sku}.`);
    }

    const subtotal = saleItems.reduce((s,it)=>s + it.qty * it.unitPrice, 0);
    const total = (paymentType === "Comp") ? 0 : subtotal;

    let cashGiven = null;
    let changeProvided = null;

    if (paymentType === "Cash") {
      const tendered = (cashMode === "other") ? parseCashOther() : cashTendered;
      if (tendered == null) return alert("Select or enter the cash amount received.");
      if (tendered < subtotal) return alert("Cash received cannot be less than the Subtotal.");

      cashGiven = tendered;
      changeProvided = Math.max(0, tendered - subtotal);
    }

    const sale = {
      type: "sale",
      saleId: uuidv4(),
      timestamp: nowIso(),
      paymentType: paymentType,
      email: ($("email").value || "").trim(),
      items: saleItems,
      subtotal: subtotal,
      total: total,
      cashGiven: cashGiven,
      changeProvided: changeProvided
    };

    // Always: apply local inventory + enqueue first (never lose a sale)
    decrementLocalInventoryForSale(sale);
    enqueueSale(sale);
    addSaleToHistory(sale);
    showReceipt(sale);

    if (sale.paymentType === "Cash") {
      alert(`Change due: ${money(sale.changeProvided ?? 0)}`);
    }

    clearCart();

    if (paymentType === "Cash") {
      cashTendered = null;
      cashMode = null;
      setCashButtonsActive(null);
      $("cashManual").style.display = "none";
      $("cashOther").value = "";
      showKeypad(false);
      updateChangeDue();
      updateCheckoutEnabled();
    }

    // If online: attempt immediate sync
    if (navigator.onLine) {
      try { await syncQueue(); } catch (e) { /* keep queued */ }
    }

    render();

  } finally {
    // --- always unlock, even if an alert/return happened ---
    isCheckingOut = false;
    updateCheckoutEnabled();
  }
}


/** ====== STARTUP ====== **/
async function boot() {
  await refreshOnlineStatus();

  // Load cached items first
  const cached = loadJSON(K_ITEMS, []);
  if (cached.length) {
    items = cached;
    ensureLocalInvInitialized(items);
    render();
  }

  // Try to refresh from API if online
  if (navigator.onLine) {
    try {
     const fresh = await apiGetItems();

// HARD BLOCK: remove Alcohol items entirely
items = fresh.filter(i => String(i.category || "").trim().toLowerCase() !== "alcohol");

saveJSON(K_ITEMS, items);

// Live inventory = server remaining minus any still-queued unsynced sales
rebuildLocalInvFromServerAndQueue(items);

render();


    } catch (e) {
      // stay on cached
    }
  }

  // Update UI
  // setOnlineUI(navigator.onLine);
  renderSyncPill();
}

window.addEventListener("online", async () => {
  await refreshOnlineStatus();
  try { await syncQueue(); } catch {}
});

window.addEventListener("offline", async () => {
  await refreshOnlineStatus();
});


$("checkoutBtn").onclick = completeSale;
$("clearBtn").onclick = () => { if (confirm("Clear the cart?")) clearCart(); };
$("printBtn").onclick = () => $("receiptBox").style.display = $("receiptBox").style.display === "none" ? "block" : "none";
$("syncBtn").onclick = async () => {
  try {
    const before = loadJSON(K_QUEUE, []).length;

    if (!navigator.onLine) {
      alert("Offline. Nothing sent (transactions are still queued).");
      return;
    }

    await syncQueue();

    const after = loadJSON(K_QUEUE, []).length;
    const sent = before - after;

    if (sent > 0) {
      alert(`Synced ${sent} transaction(s). Remaining in queue: ${after}.`);
    } else {
      alert(`Nothing new to sync. Queue: ${after}.`);
    }
  } catch (e) {
    alert(String(e.message || e));
  }
};


// ====== VOID / REFUND bindings (Step 7.7) ======
$("voidBtn").onclick = openVoidModal;
$("voidCloseBtn").onclick = closeVoidModal;
$("refundCash").onclick = () => { refundMethod = "Cash"; $("refundCash").classList.add("active"); $("refundVenmo").classList.remove("active"); };
$("refundVenmo").onclick = () => { refundMethod = "Venmo"; $("refundVenmo").classList.add("active"); $("refundCash").classList.remove("active"); };
$("voidConfirmBtn").onclick = confirmVoid;


  // Payment toggle buttons
$("payCash").onclick = () => setPayment("Cash");
$("payVenmo").onclick = () => setPayment("Venmo");
$("payComp").onclick = () => setPayment("Comp");


// Cash quick buttons (with deselect toggle + keypad)
document.querySelectorAll(".cashBtn").forEach(btn => {
  btn.onclick = () => {
    const v = btn.dataset.amt;

    // Toggle off if clicking same amount again (NOT for "other")
    if (cashMode === v && v !== "other") {
      cashMode = null;
      cashTendered = null;
      setCashButtonsActive(null);
      $("cashManual").style.display = "none";
      showKeypad(false);
      if ($("cashOther")) $("cashOther").value = "";
      updateChangeDue();
      updateCheckoutEnabled();
      return;
    }

    cashMode = v;
    setCashButtonsActive(v);

    if (v === "other") {
      cashTendered = null;
      $("cashManual").style.display = "block";
      showKeypad(true);
      setCashOtherValue(""); // clears and updates change/checkout
    } else {
      showKeypad(false);
      $("cashManual").style.display = "none";
      if ($("cashOther")) $("cashOther").value = "";
      cashTendered = Number(v);
    }

    updateChangeDue();
    updateCheckoutEnabled();
  };
});

// Tapping the readonly input opens keypad (only if Other mode is active)
$("cashOther").addEventListener("click", () => {
  if (cashMode === "other") showKeypad(true);
});

// Keypad button clicks
document.querySelectorAll("#keypad .key[data-k]").forEach(btn => {
  btn.onclick = () => {
    const k = btn.dataset.k;
    if (k === "back") return keypadBackspace();
    keypadAppend(k);
  };
});

$("keyClear").onclick = () => setCashOtherValue("");
$("keyDone").onclick = () => showKeypad(false);

setPayment("Cash");   // default
boot();
</script> 
</body>
</html>












































































